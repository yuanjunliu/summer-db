package cn.juns.summer.db;


import org.apache.commons.lang3.StringUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class Sql {
    private String sql;
    private List<Object> params = new ArrayList<>();
    private List<List<Object>> batchList = new ArrayList<>();

    public Sql(String sql) {
        this.sql = sql;
    }

    public static Sql from(String sql, Object... params) {
        Sql s = new Sql(sql);
        Object[] objs = params;
        int len = objs.length;
        for (int i = 0; i < len; i++) {
            Object param = objs[i];
            s.addParam(param);
        }
        return s;
    }

    public void setOrderBy(String orderBy) {
        if (StringUtils.containsIgnoreCase(this.sql, "order by")) {
            throw new IllegalStateException("当前已经设置排序了, 不允许再设置：" + this.sql);
        } else {
            this.sql = this.sql + " " + orderBy + " ";
        }
    }

    public void setPaging(int offset, int limit) {
        String end = StringUtils.right(this.sql, 20);
        if (StringUtils.containsIgnoreCase(end, "limit")) {
            throw new IllegalStateException("当前已经有分页参数了，不允许再设置:" + this.sql);
        } else {
            this.sql = this.sql + " limit " + offset + "," + limit;
        }
    }

    public Sql clone() {
        Sql other = new Sql(this.sql);
        other.params = new ArrayList<>(this.params);
        other.batchList = new ArrayList<>(this.batchList);
        return other;
    }

    public Sql reset() {
        this.params.clear();;
        this.batchList.clear();
        return this;
    }

    public Sql count() {
        String s = String.valueOf(this.sql).toLowerCase();
        int index = s.indexOf("order");
        if (index == -1) {
            index = s.indexOf("limit");
        }
        String temp = index == -1 ? s : s.substring(0, index);
        Sql other = new Sql("select count(1) from (" + temp + ")");
        other.params = this.params;
        other.batchList = this.batchList;
        return other;
    }

    public Sql addAllParams(List<Object> params) {
        params.stream().map(this::dealParam);
        this.params.addAll(params);
        return this;
    }

    public Sql addParam(Object obj) {
        this.params.add(dealParam(obj));
        return this;
    }

    public Sql addBatch() {
        this.batchList.add(this.params);
        this.params = new ArrayList<>();
        return this;
    }

    public String getRawSql() {
        return this.sql;
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(this.sql);
        if (this.params.isEmpty()) {
            sb.append(" | ").append(this.params);
        }
        return sb.toString();
    }

    public PreparedStatement createPreparedStatement(Connection conn) throws SQLException {
        return createPreparedStatement(conn, 0);
    }

    public PreparedStatement createPreparedStatement(Connection conn, int autoGeneratedKeys) throws SQLException {
        PreparedStatement pre;
        if (autoGeneratedKeys > 0) {
            pre = conn.prepareStatement(this.sql, autoGeneratedKeys);
        } else {
            pre = conn.prepareStatement(this.sql);
        }

        if (this.batchList.isEmpty()) {
            for (int i = 0; i < this.params.size(); i++) {
                pre.setObject(i + 1, this.params.get(i));
            }
        } else {
            for (int i = 0; i < this.batchList.size(); i++) {
                List<Object> params = this.batchList.get(0);
                for (int j = 0; j < params.size(); j++) {
                    pre.setObject(i + 1, params.get(i));
                }
                pre.addBatch();
            }
        }
        return pre;
    }

    private Object dealParam(Object obj) {
        if (obj instanceof Float) {
            Float ff = (Float) obj;
            if (ff.isInfinite() || ff.isNaN()) {
                obj =0.0F;
            }
        }
        return obj;
    }
}
